#==============================================================================
#
#          FILE:  functions
#         USAGE:  . functions
#   DESCRIPTION:  Sets application-wide functions
#
#       OPTIONS:  ---
#  REQUIREMENTS:  ---
#          BUGS:  ---
#         NOTES:  ---
#        AUTHOR:  Kevin Huntly <kmhuntly@gmail.com>
#       COMPANY:  CaspersBox Web Services
#       VERSION:  1.0
#       CREATED:  ---
#      REVISION:  ---
#
#==============================================================================

#===  FUNCTION  ===============================================================
#          NAME:  returnEpochTime
#   DESCRIPTION:  Cleans up the archived log directory
#    PARAMETERS:  Archive Directory, Logfile Name, Retention Time
#       RETURNS:  0 regardless of result.
#==============================================================================
function returnEpochTime
{
    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set -x;

    if [ ${#} -eq 0 ]
    then
        echo "${0} - Generates and returns the Unix epoch for a provided date (or date range).";
        echo " Required arguments: The date to convert in form YYYY MM DD, quoted. (if provided, MUST be qouted)";
        echo " Optional arguments: A number of days to calculate a future epoch, for example, 45.";
        echo " Example: returnEpochTime \"2011 11 18\" 45";

        return 1;
    fi

    case ${#} in
        2)
            echo ${@} | /usr/bin/env perl -MTime::Local -ane '
                qw(timelocal);

                my $seconds = (3600 * 24);
                my $now = timelocal(0, 0, 0, $F[2], $F[1] - 1, $F[0]);
                my $validationPeriod = $now + ($F[3] * $seconds);

                echo "$validationPeriod\n"; ';
            ;;
        4)
            ## supposed to be quoted but support it anyway
            echo ${@} | /usr/bin/env perl -MTime::Local -ane '
                qw(timelocal);

                my $seconds = (3600 * 24);
                my $now = timelocal(0, 0, 0, $F[2], $F[1] - 1, $F[0]);
                my $validationPeriod = $now + ($F[3] * $seconds);

                echo "$validationPeriod\n"; ';
            ;;
        *)
            echo ${@} | /usr/bin/env perl -MTime::Local -ane '
                qw(timelocal);
                my $epochtime = timelocal(0, 0, 0, $F[2], $F[1] - 1, $F[0]);
                echo "$epochtime\n"; ';
            ;;
    esac

    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set +x;

    return 0;
}

#===  FUNCTION  ===============================================================
#          NAME:  obtainLogWatchStamp
#   DESCRIPTION:  Cleans up the archived log directory
#    PARAMETERS:  Archive Directory, Logfile Name, Retention Time
#       RETURNS:  0 regardless of result.
#==============================================================================
function obtainLogWatchStamp
{
    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set -x;

    /usr/bin/env perl -e '
        @d=localtime time() - $ENV{"LOG_FILE_DELAY"};
        printf "%02d:%02d:%02d\n", $d[2],$d[1],$d[0];';

    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set +x;

    return 0;
}

#===  FUNCTION  ===============================================================
#          NAME:  getFileStat
#   DESCRIPTION:  Cleans up the archived log directory
#    PARAMETERS:  Archive Directory, Logfile Name, Retention Time
#       RETURNS:  0 regardless of result.
#==============================================================================
function getFileStat
{
    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set -x;

    /usr/bin/env perl -e '
        @d=localtime ((stat(shift)) [10]);
        printf "%4d%02d%02d\n", $d[5]+1900,$d[4]+1,$d[3]' ${1};

    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set +x;

    return 0;
}

#===  FUNCTION  ===============================================================
#          NAME:  isNaN
#   DESCRIPTION:  Cleans up the archived log directory
#    PARAMETERS:  Archive Directory, Logfile Name, Retention Time
#       RETURNS:  0 regardless of result.
#==============================================================================
function isNaN
{
    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set -x;

    [ -z "${1}" ] && echo 1;

    case ${1} in
        ?([+-])+([0-9])) echo 0 ;;
        *) echo 1 ;;
    esac

    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set +x;

    return 0;
}

#===  FUNCTION  ===============================================================
#          NAME:  cleanLogArchive
#   DESCRIPTION:  Cleans up the archived log directory
#    PARAMETERS:  Archive Directory, Logfile Name, Retention Time
#       RETURNS:  0 regardless of result.
#==============================================================================
function contains
{
    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set -x;

    typeset -i COUNTER=0;

    (( LAST_ARG = ${#} - 1))
    eval SEARCH_STRING=\$$#;

    for ARGUMENT in ${@}
    do
        [ ${COUNTER} == ${LAST_ARG} ] && break;

        [ "${ARGUMENT}" == "${SEARCH_STRING}" ] && return 0;

        (( COUNTER += 1 ));
    done

    unset COUNTER;
    unset LAST_ARG;
    unset ARGUMENT;
    unset SEARCH_STRING;

    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set +x;

    return 1;
}

#===  FUNCTION  ===============================================================
#          NAME:  cancelRequest
#   DESCRIPTION:  Cancels and restarts processing from the main entry point
#    PARAMETERS:  LOAD_CLASS - The class to launch post-cancellation
#       RETURNS:  0 regardless of result.
#==============================================================================
function cancelRequest
{
    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set -x;

    reset; clear;

    [[ ! -z ${VERBOSE} && "${VERBOSE}" == "${_TRUE}" ]] && $(${LOGGER} DEBUG ${METHOD_NAME} ${CNAME} ${LINENO} "Request processing canceled.");

    print "$(cat ${SYSTEM_MESSAGES} | grep system.request.canceled | grep -v "#" | cut -d "=" -f 2)\n";

    ## terminate this thread and return control to main
    [[ ! -z ${VERBOSE} && "${VERBOSE}" == "${_TRUE}" ]] && $(${LOGGER} DEBUG ${METHOD_NAME} ${CNAME} ${LINENO} "${METHOD_NAME} -> exit");

    sleep ${MESSAGE_DELAY}; reset; clear;
    [ -z "${1}" ] && exec ${APP_ROOT}/${MAIN_CLASS} || exec ${1};

    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set +x;

    return 0;
}

#===  FUNCTION  ===============================================================
#          NAME:  stringCrypt
#   DESCRIPTION:  Encrypt/decrypt a provided string
#    PARAMETERS:  Operation type, String to encrypt/decrypt, salt to
#                 encrypt/decrypt with
#       RETURNS:  0 if success, 1 otherwise
#==============================================================================
function stringCrypt
{
    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set -x;

    if [ ${#} -ne 3 ]
    then
        echo "${0} - Encrypt/Decrypt a provided string";
        echo "Usage: ${0} method string";
        echo "  method             The desired method of operation: one of encrypt or decrypt";
        echo "  string             The string to operate against";
        echo "  pass               The password to utilize";
        echo "\tauthentication     Specify an authentication mechanism. One of 'pass', 'file' can be provided in the following formats:";
        echo "\t\t For password authentication: pass:the-password";
        echo "\t\t To use a file containing the password, provide file:/path/to/file.";

        RETURN_CODE=1;
    fi

    case ${1} in
        [Ee][Nn][Cc][Rr][Yy][Pp][Tt]|e)
            echo "${2}" | /usr/bin/env openssl enc -aes-256-cbc -a -salt -pass ${3};

            return ${?};
            ;;
        [Dd][Ee][Cc][Rr][Yy][Pp][Tt]|d)
            echo "${2}" | /usr/bin/env openssl enc -aes-256-cbc -a -d -salt -pass ${3};

            RETURN_CODE=${?};
            ;;
        *)
            echo "Invalid method argument";

            RETURN_CODE=1;
            ;;
    esac

    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set +x;

    return ${RETURN_CODE};
}

#===  FUNCTION  ===============================================================
#          NAME:  getKey
#   DESCRIPTION:  Obtains and stores the public key for a remote SSH node
#    PARAMETERS:  Target host to obtain keys for
#       RETURNS:  0 if success, 1 otherwise
#==============================================================================
function getKey
{
    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set -x;

    [ ${#} -eq 0 ] && echo "A hostname must be provided" && return 1;
    [ "$(/usr/bin/env dig +short -t a ${1})" != ""] && echo "Host ${1} not found in DNS" && return 1;

    /usr/bin/env ssh-keyscan -t rsa ${1} 2>>~/.ssh/known_hosts 1>>~/.ssh/known_hosts;
    /usr/bin/env ssh-keyscan -t dsa ${1} 2>/dev/null 1>>~/.ssh/known_hosts;

    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set +x;

    return ${?};
}

#===  FUNCTION  ===============================================================
#          NAME:  distributePackage
#   DESCRIPTION:  Creates a backup archive of a desired filesystem via rsync
#    PARAMETERS:  Target host to obtain keys for
#       RETURNS:  0 if success, 1 otherwise
#==============================================================================
function distributePackage
{
    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set -x;

    if [ ${#} -ne 4 ]
    then
        print "${0} - Perform an rsync backup of a remote filesystem";
        print "Usage: ${0} [ username ] [ source ] [ hostname ] [ destination ]";
        print " -> The username to execute the rsync (and subsequent ssh) as.";
        print " -> The source directory to obtain";
        print " -> The target host to obtain the source from";
        print " -> The target directory to store the source into";

        return 1;
    fi

    ## create the exclude file if not exists - rsync will choke otherwise
    [ -z "${THREAD_TIMEOUT}" ] && TIMEOUT_VALUE=30 || TIMEOUT_VALUE=${THREAD_TIMEOUT};
    [ ! -f ${1}/.etc/excludes ] && touch ${1}/.etc/excludes;

    /usr/bin/env rsync -vqcarupeAtzhi --timeout ${TIMEOUT_VALUE} --no-motd --safe-links --delete --delete-excluded --progress --exclude-from=${1}/.etc/excludes -e "/usr/bin/env ssh -q -t -l ${1}" ${2} ${3}:${4};

    unset TIMEOUT_VALUE;

    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set +x;

    return ${?};
}

#===  FUNCTION  ===============================================================
#          NAME:  createBackup
#   DESCRIPTION:  Obtains and stores the public key for a remote SSH node
#    PARAMETERS:  Target host to obtain keys for
#       RETURNS:  0 if success, 1 otherwise
#==============================================================================
function createBackup
{
    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set -x;

    if [ ${#} -ne 4 ]
    then
        print "${0} - Perform an rsync backup of a remote filesystem";
        print "Usage: ${0} [ username ] [ source ] [ hostname ] [ destination ]";
        print " -> The username to execute the rsync (and subsequent ssh) as.";
        print " -> The source directory to obtain";
        print " -> The target host to obtain the source from";
        print " -> The target directory to store the source into";

        return 1;
    fi

    ## create the exclude file if not exists - rsync will choke otherwise
    [ -z "${THREAD_TIMEOUT}" ] && TIMEOUT_VALUE=30 || TIMEOUT_VALUE=${THREAD_TIMEOUT};
    [ ! -f ${1}/.etc/excludes ] && touch ${1}/.etc/excludes;
    [ ! -d ${4} ] && mkdir -p ${4};

    /usr/bin/env rsync -vqcarupeAtzhi --timeout ${TIMEOUT_VALUE} --no-motd --safe-links --delete --delete-excluded --progress --exclude-from=${1}/.etc/excludes -e "/usr/bin/env ssh -q -t -l ${1}" ${3}:${2} ${4};

    unset TIMEOUT_VALUE;

    [[ ! -z "${TRACE}" && "${TRACE}" = "TRUE" ]] && set +x;

    return ${?};
}
