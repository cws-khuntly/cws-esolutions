#==============================================================================
#
#          FILE:  functions
#         USAGE:  . functions
#   DESCRIPTION:  Sets application-wide functions
#
#       OPTIONS:  ---
#  REQUIREMENTS:  ---
#          BUGS:  ---
#         NOTES:  ---
#        AUTHOR:  Kevin Huntly <kmhuntly@gmail.com>
#       COMPANY:  ---
#       VERSION:  1.0
#       CREATED:  ---
#      REVISION:  ---
#
#==============================================================================

## converts YYYY MM DD (2011 08 17) to epoch
function returnEpochTime
{
    if [ ${#} -eq 0 ]
    then
        echo "${0} - Generates and returns the Unix epoch for a provided date (or date range).";
        echo " Required arguments: The date to convert in form YYYY MM DD, quoted. (if provided, MUST be qouted)";
        echo " Optional arguments: A number of days to calculate a future epoch, for example, 45.";
        echo " Example: returnEpochTime \"2011 11 18\" 45";

        return 1;
    fi

    case ${#} in
        2)
            echo ${@} | /usr/bin/env perl -MTime::Local -ane '
                qw(timelocal);

                my $seconds = (3600 * 24);
                my $now = timelocal(0, 0, 0, $F[2], $F[1] - 1, $F[0]);
                my $validationPeriod = $now + ($F[3] * $seconds);

                echo "$validationPeriod\n"; ';
            ;;
        4)
            ## supposed to be quoted but support it anyway
            echo ${@} | /usr/bin/env perl -MTime::Local -ane '
                qw(timelocal);

                my $seconds = (3600 * 24);
                my $now = timelocal(0, 0, 0, $F[2], $F[1] - 1, $F[0]);
                my $validationPeriod = $now + ($F[3] * $seconds);

                echo "$validationPeriod\n"; ';
            ;;
        *)
            echo ${@} | /usr/bin/env perl -MTime::Local -ane '
                qw(timelocal);
                my $epochtime = timelocal(0, 0, 0, $F[2], $F[1] - 1, $F[0]);
                echo "$epochtime\n"; ';
            ;;
    esac

    return 0;
}

function obtainLogWatchStamp
{
    /usr/bin/env perl -e '
        @d=localtime time() - $ENV{"LOG_FILE_DELAY"};
        printf "%02d:%02d:%02d\n", $d[2],$d[1],$d[0];';

    return 0;
}

function getFileStat
{
    /usr/bin/env perl -e '
        @d=localtime ((stat(shift)) [10]);
        printf "%4d%02d%02d\n", $d[5]+1900,$d[4]+1,$d[3]' ${1};

    return 0;
}

function isNaN
{
    if [ ! -z "${1}" ]
    then
        case ${1} in
            ?([+-])+([0-9]))
                echo ${_TRUE};
                ;;
            *)
                echo ${_FALSE};
                ;;
        esac
    else
        return 1;
    fi
}

#===  FUNCTION  ===============================================================
#          NAME:  cleanLogArchive
#   DESCRIPTION:  Cleans up the archived log directory
#    PARAMETERS:  Archive Directory, Logfile Name, Retention Time
#       RETURNS:  0 regardless of result.
#==============================================================================
function cleanLogArchive
{
    [ ${#} -ne 2 ] && return 1;
    [ ! -d ${1} ] return 0;

    for ARCHIVED_FILE in $(find ${1} -type f -name ${2}\* -ctime +${3})
    do
        [ -f ${1}/${2} ] && rm -f ${ARCHIVED_FILE} >/dev/null 2>&1;
    done

    return 0;
}

#===  FUNCTION  ===============================================================
#          NAME:  rotateLog
#   DESCRIPTION:  Rotates log files based on size or time.
#    PARAMETERS:  The log file name to take action against
#       RETURNS:  0 regardless of result.
#==============================================================================
function rotateLogs
{
    [[ -z "${APP_LOGGING_CONFIG}" || -z "${LOGGER}" ]] && return 0;
    [ ! -f ${LOG_ROOT}/${1} ] && return 0;

    if [ $(( $(date +"%s") - $(stat -L --format %Y ${LOG_ROOT}/${1}) > $(echo "${ROLLOVER_PERIOD} * 60 * 60" | bc) )) == 1 ]
    then
        if [ -f ${LOG_ROOT}/${1}.${LOG_RETENTION_PERIOD} ]
        then
            [ ${ARCHIVE_ENABLED} ] && mv ${LOG_ROOT}/${1}.${LOG_RETENTION_PERIOD} ${ARCHIVE_LOG_ROOT} || rm -f ${LOG_ROOT}/${1}.${LOG_RETENTION_PERIOD};
        fi

        ## rotate logs
        A=${LOG_RETENTION_PERIOD};

        while (( ${A} != 0 ))
        do
            [ -f ${LOG_ROOT}/${1}.${A} ] && mv ${LOG_ROOT}/${1}.${A} ${LOG_ROOT}/${1}.$(expr ${A} + 1);

            (( A -= 1 ))
        done

        mv ${LOG_ROOT}/${1} ${LOG_ROOT}/${1}.1;
        touch ${LOG_ROOT}/${1};
    fi

    if [ $(/usr/bin/env stat -c %s "${LOG_ROOT}/${1}") -gt $(echo "${ROTATE_ON_SIZE} * 1024" | bc) ]
    then
        if [ -f ${LOG_ROOT}/${1}.${LOG_RETENTION_PERIOD} ]
        then
            [ ${ARCHIVE_ENABLED} ] && mv ${LOG_ROOT}/${1}.${LOG_RETENTION_PERIOD} ${ARCHIVE_LOG_ROOT} || rm -f ${LOG_ROOT}/${1}.${LOG_RETENTION_PERIOD};
        fi

        ## rotate logs
        A=${LOG_RETENTION_PERIOD};

        while (( ${A} != 0 ))
        do
            [ -f ${LOG_ROOT}/${1}.${A} ] && mv ${LOG_ROOT}/${1}.${A} ${LOG_ROOT}/${1}.$(expr ${A} + 1);

            (( A -= 1 ))
        done

        mv ${LOG_ROOT}/${1} ${LOG_ROOT}/${1}.1;
        touch ${LOG_ROOT}/${1};
    fi

    return 0;
}

function contains
{
    typeset -i COUNTER=0;

    (( LAST_ARG = ${#} - 1))
    eval SEARCH_STRING=\$$#;

    for ARGUMENT in ${@}
    do
        [ ${COUNTER} == ${LAST_ARG} ] && break;

        [ "${ARGUMENT}" == "${SEARCH_STRING}" ] && return 0;

        (( COUNTER += 1 ));
    done

    unset COUNTER;
    unset LAST_ARG;
    unset ARGUMENT;
    unset SEARCH_STRING;

    return 1;
}

#===  FUNCTION  ===============================================================
#          NAME:  cancelRequest
#   DESCRIPTION:  Cancels and restarts processing from the main entry point
#    PARAMETERS:  LOAD_CLASS - The class to launch post-cancellation
#       RETURNS:  0 regardless of result.
#==============================================================================
function cancelRequest
{
    reset; clear;

    [[ ! -z ${VERBOSE} && "${VERBOSE}" == "${_TRUE}" ]] && $(${LOGGER} DEBUG ${METHOD_NAME} ${CNAME} ${LINENO} "Request processing canceled.");

    print "$(cat ${SYSTEM_MESSAGES} | grep system.request.canceled | grep -v "#" | cut -d "=" -f 2)\n";

    ## terminate this thread and return control to main
    [[ ! -z ${VERBOSE} && "${VERBOSE}" == "${_TRUE}" ]] && $(${LOGGER} DEBUG ${METHOD_NAME} ${CNAME} ${LINENO} "${METHOD_NAME} -> exit");

    sleep ${MESSAGE_DELAY}; reset; clear;
    [ -z "${1}" ] && exec ${APP_ROOT}/${MAIN_CLASS} || exec ${1};

    return 0;
}

#===  FUNCTION  ===============================================================
#          NAME:  stringCrypt
#   DESCRIPTION:  Encrypt/decrypt a provided string
#    PARAMETERS:  Operation type, String to encrypt/decrypt, salt to
#                 encrypt/decrypt with
#       RETURNS:  0 if success, 1 otherwise
#==============================================================================
function stringCrypt
{
    if [ ${#} -ne 3 ]
    then
        echo "${0} - Encrypt/Decrypt a provided string";
        echo "Usage: ${0} method string";
        echo "  method             The desired method of operation: one of encrypt or decrypt";
        echo "  string             The string to operate against";
        echo "  pass               The password to utilize";
        echo "\tauthentication     Specify an authentication mechanism. One of 'pass', 'file' can be provided in the following formats:";
        echo "\t\t For password authentication: pass:the-password";
        echo "\t\t To use a file containing the password, provide file:/path/to/file.";

        return 1;
    fi

    case ${1} in
        [Ee][Nn][Cc][Rr][Yy][Pp][Tt]|e)
            echo "${2}" | /usr/bin/env openssl enc -aes-256-cbc -a -salt -pass ${3};

            return ${?};
            ;;
        [Dd][Ee][Cc][Rr][Yy][Pp][Tt]|d)
            echo "${2}" | /usr/bin/env openssl enc -aes-256-cbc -a -d -salt -pass ${3};

            return ${?};
            ;;
        *)
            echo "Invalid method argument";

            return 1;
            ;;
    esac
}

#===  FUNCTION  ===============================================================
#          NAME:  getKey
#   DESCRIPTION:  Obtains and stores the public key for a remote SSH node
#    PARAMETERS:  Target host to obtain keys for
#       RETURNS:  0 if success, 1 otherwise
#==============================================================================
function getKey
{
    [ ${#} -eq 0 ] && echo "A hostname must be provided" && return 1;
    [ "$(/usr/bin/env dig +short -t a ${1})" != ""] && echo "Host ${1} not found in DNS" && return 1;

    /usr/bin/env ssh-keyscan -t rsa ${1} 2>>~/.ssh/known_hosts 1>>~/.ssh/known_hosts;
    /usr/bin/env ssh-keyscan -t dsa ${1} 2>/dev/null 1>>~/.ssh/known_hosts;

    return ${?};
}

#===  FUNCTION  ===============================================================
#          NAME:  distributePackage
#   DESCRIPTION:  Creates a backup archive of a desired filesystem via rsync
#    PARAMETERS:  Target host to obtain keys for
#       RETURNS:  0 if success, 1 otherwise
#==============================================================================
function distributePackage
{
    if [ ${#} -ne 4 ]
    then
        print "${0} - Perform an rsync backup of a remote filesystem";
        print "Usage: ${0} [ username ] [ source ] [ hostname ] [ destination ]";
        print " -> The username to execute the rsync (and subsequent ssh) as.";
        print " -> The source directory to obtain";
        print " -> The target host to obtain the source from";
        print " -> The target directory to store the source into";

        return 1;
    fi

    ## create the exclude file if not exists - rsync will choke otherwise
    [ -z "${THREAD_TIMEOUT}" ] && TIMEOUT_VALUE=30 || TIMEOUT_VALUE=${THREAD_TIMEOUT};
    [ ! -f ${1}/.etc/excludes ] && touch ${1}/.etc/excludes;

    /usr/bin/env rsync -vqcarupeAtzhi --timeout ${TIMEOUT_VALUE} --no-motd --safe-links --delete --delete-excluded --progress --exclude-from=${1}/.etc/excludes -e "/usr/bin/env ssh -q -t -l ${1}" ${2} ${3}:${4};

    unset TIMEOUT_VALUE;

    return ${?};
}

#===  FUNCTION  ===============================================================
#          NAME:  createBackup
#   DESCRIPTION:  Obtains and stores the public key for a remote SSH node
#    PARAMETERS:  Target host to obtain keys for
#       RETURNS:  0 if success, 1 otherwise
#==============================================================================
function createBackup
{
    if [ ${#} -ne 4 ]
    then
        print "${0} - Perform an rsync backup of a remote filesystem";
        print "Usage: ${0} [ username ] [ source ] [ hostname ] [ destination ]";
        print " -> The username to execute the rsync (and subsequent ssh) as.";
        print " -> The source directory to obtain";
        print " -> The target host to obtain the source from";
        print " -> The target directory to store the source into";

        return 1;
    fi

    ## create the exclude file if not exists - rsync will choke otherwise
    [ -z "${THREAD_TIMEOUT}" ] && TIMEOUT_VALUE=30 || TIMEOUT_VALUE=${THREAD_TIMEOUT};
    [ ! -f ${1}/.etc/excludes ] && touch ${1}/.etc/excludes;
    [ ! -d ${4} ] && mkdir -p ${4};

    /usr/bin/env rsync -vqcarupeAtzhi --timeout ${TIMEOUT_VALUE} --no-motd --safe-links --delete --delete-excluded --progress --exclude-from=${1}/.etc/excludes -e "/usr/bin/env ssh -q -t -l ${1}" ${3}:${2} ${4};

    unset TIMEOUT_VALUE;

    return ${?};
}
