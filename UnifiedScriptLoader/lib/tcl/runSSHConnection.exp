#!/usr/bin/env expect
#==============================================================================
#
#          FILE:  runSSHConnection.exp
#         USAGE:  ./runSSHConnection.exp
#   DESCRIPTION:  Executes an scp connection to a pre-defined server
#
#       OPTIONS:  ---
#  REQUIREMENTS:  ---
#          BUGS:  ---
#         NOTES:  ---
#        AUTHOR:  Kevin Huntly <kmhuntly@gmail.com>
#       COMPANY:  CaspersBox Web Services
#       VERSION:  1.0
#       CREATED:  ---
#      REVISION:  ---
#
#==============================================================================

## set up some class info
global _CNAME
global _LINE_TERMINATOR

set _CNAME "runSSHConnection.exp"
set _LINE_TERMINATOR $env(TRACE)
set timeout $env(THREAD_TIMEOUT)

# turn off screen echo
if { [string compare -nocase $env(TRACE) "true"] != 0 } {
    log_user 1
} else {
    log_user 0
}

proc usage {} {
    global _CNAME

    puts "$_CNAME Perform an automated SSH-based task without user interaction.";
    puts "Usage: $_CNAME \[ host \] \[ command \] \[ user \] ( authentication mechanism ) ( timeout )";
    puts "\thost                The target hostname to connect to. The host must be either an IP address or resolvable hostname."
    puts "\tcommand             The command to execute on the remote system. If an interactive shell is required, specify 'shell' here."
    puts "\tusername            The user to connect to the remote system as."
    puts "\tauthentication      (Optional) Specify an authentication mechanism. One of 'pass', 'key', or 'file' can be provided in the following formats:"
    puts "\t\t For password authentication: pass:the-password"
    puts "\t\t For key-based authentication: key:/path/to/key. If a passphrase is required by the key, the syntax becomes key:/path/to/key:passphrase"
    puts "\t\t To use a file containing the authentication information. The following syntaxes are available:"
    puts "\t\t\t hostname:username:type:value(:value)"
    puts "\t\t The same syntax rules as above apply here as well."
}

## make sure we have all our arguments
if { [ expr $argc < 3 ] } {
    usage

    exit 1
} else {
    ## set runtime information
    set _TARGET_SYSTEM [ lindex $argv 0 ]
    set _EXEC_CMD [ lindex $argv 1 ]
    set _USER_LOGINID [ lindex $argv 2 ]

    ## type it
    if { [string compare -nocase [ lindex $argv 3 ] ""] != 0 } {
        set _AUTH_STRING [ split [ lindex $argv 3 ] ":" ]

        if { [ string compare -nocase [ lindex $_AUTH_STRING 0 ] "pass" ] == 0 } {
            ## password authentication only
            set _USER_PASSWD [ lindex $_AUTH_STRING 1 ]
        } elseif { [ string compare -nocase [ lindex $_AUTH_STRING 0 ] "key" ] == 0 } {
            ## key auth
            set _USER_KEY [ lindex $_AUTH_STRING 1 ]

            if { [ llength $_AUTH_STRING ] == 3 } {
                ## key has a password
                set _USER_PASSWD [ lindex $_AUTH_STRING 2 ]
            }
        } elseif { [ string compare -nocase [ lindex $_AUTH_STRING 0 ] "file" ] == 0 } {
            set file [ open [ lindex $_AUTH_STRING 1 ] r ]
            fconfigure $file -buffering line

            while { [ gets $file line ] >= 0 } {
                if { [ string match "$$*" $line ] || [ string match "$ #*" $line ] } {
                    # ignore by just going straight to the next loop iteration
                    continue
                }

                set _AUTH_ENTRY [ split $line ":" ]

                if { [ string equal -nocase -length [ string length $_TARGET_SYSTEM ] $_TARGET_SYSTEM [ lindex $_AUTH_ENTRY 0 ] ] == 1 } {
                    if { [ string equal -nocase -length [ string length $_USER_LOGINID ] $_USER_LOGINID [ lindex $_AUTH_ENTRY 1 ] ] == 1 } {
                        set _AUTH_DATA $_AUTH_ENTRY

                        break
                    } else {
                        continue
                    }
                } else {
                    continue
                }

                if { [ string equal -nocase -length [ string length $_USER_LOGINID ] $_USER_LOGINID [ lindex $_AUTH_ENTRY 0 ] ] == 1 } {
                    set _AUTH_DATA $_AUTH_ENTRY

                    break
                } else {
                    continue
                }
            }

            close $file

            ## check what we have
            ## two possible formats:
            ## host:user:type:value(:value) (0:1:2:3:4)
            ## user:type:value(:value)  (0:1:2:3)
            if { [ string equal -nocase -length [ string length $_TARGET_SYSTEM ] $_TARGET_SYSTEM [ lindex $_AUTH_DATA 0 ] ] == 1 } {
                if { [ string compare -nocase [ lindex $_AUTH_DATA 2 ] "pass" ] == 0 } {
                    ## password authentication only
                    set _USER_PASSWD [ lindex $_AUTH_DATA 3 ]
                } elseif { [ string compare -nocase [ lindex $_AUTH_DATA 2 ] "key" ] == 0 } {
                    ## key auth
                    set _USER_KEY [ lindex $_AUTH_DATA 3 ]

                    if { [ llength $_AUTH_DATA ] == 5 } {
                        ## key has a password
                        set _USER_PASSWD [ lindex $_AUTH_DATA 4 ]
                    }
                } else {
                    puts "No valid authentication type was provided. Cannot continue."

                    exit 1
                }
            } elseif { [ string equal -nocase -length [ string length $_USER_LOGINID ] $_USER_LOGINID [ lindex $_AUTH_DATA 0 ] ] == 1 } {
                if { [ string compare -nocase [ lindex $_AUTH_DATA 1 ] "pass" ] == 0 } {
                    ## password authentication only
                    set _USER_PASSWD [ lindex $_AUTH_DATA 2 ]
                } elseif { [ string compare -nocase [ lindex $_AUTH_DATA 1 ] "key" ] == 0 } {
                    ## key auth
                    set _USER_KEY [ lindex $_AUTH_DATA 2 ]

                    if { [ llength $_AUTH_DATA ] == 4 } {
                        ## key has a password
                        set _USER_PASSWD [ lindex $_AUTH_DATA 3 ]
                    }
                } else {
                    puts "No valid authentication type was provided. Cannot continue."

                    exit 1
                }
            } else {
                puts "No valid authentication data was provided. Cannot continue."

                exit 1
            }
        } else {
            puts "No valid authentication type was provided. Cannot continue."

            exit 1
        }
    }

    set file [ open $::env(HOME)/.etc/passphrase r ]
    fconfigure $file -buffering line

    while { [ gets $file line ] >= 0 } {
        set _SSH_PASSPHRASE $line
    }

    close $file
}

## sleep for about ten seconds
## for some reason if this script
## is executed immediately after
## a previous execution, it breaks
sleep $env(EXECUTION_DELAY)

## spawn the ssh connection
if { [ info exists _USER_LOGINID ] } {
    if { [ info exists _USER_KEY ] } {
        if { [ string compare -nocase $_USER_KEY "default" ] == 0 } {
            if { [ string compare -nocase $_EXEC_CMD "shell" ] == 0 } {
                set _SSH_COMMAND "ssh -q -t -l $_USER_LOGINID $_TARGET_SYSTEM"
            } else {
                set _SSH_COMMAND "ssh -q -t -l $_USER_LOGINID $_TARGET_SYSTEM \"$_EXEC_CMD\""
            }
        } else {
            if { [ string compare -nocase $_EXEC_CMD "shell" ] == 0 } {
                set _SSH_COMMAND "ssh -q -t -l $_USER_LOGINID -i $_USER_KEY $_TARGET_SYSTEM"
            } else {
                set _SSH_COMMAND "ssh -q -t -l $_USER_LOGINID -i $_USER_KEY $_TARGET_SYSTEM \"$_EXEC_CMD\""
            }
        }
    } else {
        if { [ string compare -nocase $_EXEC_CMD "shell" ] == 0 } {
            set _SSH_COMMAND "ssh -q -t -l $_USER_LOGINID $_TARGET_SYSTEM"
        } else {
            set _SSH_COMMAND "ssh -q -t -l $_USER_LOGINID $_TARGET_SYSTEM \"$_EXEC_CMD\""
        }
    }
} else {
    if { [ info exists _USER_KEY ] } {
        if { [ string compare -nocase $_USER_KEY "default" ] == 0 } {
            if { [ string compare -nocase $_EXEC_CMD "shell" ] == 0 } {
                set _SSH_COMMAND "ssh -q -t -l $_USER_LOGINID $_TARGET_SYSTEM"
            } else {
                set _SSH_COMMAND "ssh -q -t -l $_USER_LOGINID $_TARGET_SYSTEM \"$_EXEC_CMD\""
            }
        } else {
            if { [ string compare -nocase $_EXEC_CMD "shell" ] == 0 } {
                set _SSH_COMMAND "ssh -q -t -l $_USER_LOGINID -i $_USER_KEY $_TARGET_SYSTEM"
            } else {
                set _SSH_COMMAND "ssh -q -t -l $_USER_LOGINID -i $_USER_KEY $_TARGET_SYSTEM \"$_EXEC_CMD\""
            }
        }
    } else {
        if { [ string compare -nocase $_EXEC_CMD "shell" ] == 0 } {
            set _SSH_COMMAND "ssh -q -t -l $_USER_LOGINID $_TARGET_SYSTEM"
        } else {
            set _SSH_COMMAND "ssh -q -t -l $_USER_LOGINID $_TARGET_SYSTEM \"$_EXEC_CMD\""
        }
    }
}

if { [ info exists _SSH_COMMAND ] } {
    eval spawn $_SSH_COMMAND

    set i 0

    expect {
        "*(yes/no)? " {
            exp_send "yes\r"
            exp_continue
        }
        "*id_?sa*" {
            exp_send "$_SSH_PASSPHRASE\r"
            exp_continue
        }
        "*?assword*" {
            if { [ expr { $i == 1 } ] } {
                puts "An invalid password was provided for user account $_USER_LOGINID on host $_TARGET_SYSTEM"

                exit 1
            }

            exp_send "$_USER_PASSWD\r"

            set i [ expr { $i + 1 } ]

            exp_continue
        }
        $_LINE_TERMINATOR {
            expect {
                "*?assword*" {
                    if { [ expr { $i == 1 } ] } {
                        puts "An invalid password was provided for user account $_USER_LOGINID on host $_TARGET_SYSTEM"

                        exit 1
                    }

                    exp_send "$_USER_PASSWD\r"

                    set i [ expr { $i + 1 } ]

                    exp_continue
                }
                $_LINE_TERMINATOR {
                    if { [ string compare $_EXEC_CMD "shell" ] == 0 } {
                        interact
                    } else {
                        append output $expect_out(buffer);
                        exp_continue
                    }
                }
                eof {
                    append output $expect_out(buffer)
                    exp_continue
                }
            }
        }
        eof {
            append output $expect_out(buffer)
            exp_continue
        }
    }

    if { [ info exists output ] } {
        regsub -all -line {^[ \r\t]+|[ \r\t]+$} $output "" _RETURN_DATA
        set _PRINT_DATA [ string trimright $_RETURN_DATA \n ]

        if { [ string compare -nocase $_PRINT_DATA "" ] != 0 } {
            if { [ string is integer $_PRINT_DATA ] } {
                exit $_PRINT_DATA
            } else {
                puts $_PRINT_DATA

                exit 0
            }
        } else {
            exit 0
        }
    }
} else {
    puts "No valid SSH command was generated. Cannot continue."
    exit 27
}
