#!/usr/bin/env expect
#==============================================================================
#
#          FILE:  scp
#         USAGE:  ./scp
#   DESCRIPTION:  Executes an scp connection to a pre-defined server
#
#       OPTIONS:  ---
#  REQUIREMENTS:  ---
#          BUGS:  ---
#         NOTES:  ---
#        AUTHOR:  Kevin Huntly <kmhuntly@gmail.com>
#       COMPANY:  CaspersBox Web Services
#       VERSION:  1.0
#       CREATED:  ---
#      REVISION:  ---
#==============================================================================

if { [ info exists env(ENABLE_VERBOSE) ] } {
    if { [ string match -nocase $env(ENABLE_VERBOSE) "true" ] == 1 } {
        log_user 1
    } else {
        log_user 0
    }
} else {
    log_user 0
}

if { [ info exists env(ENABLE_TRACE) ] } {
    if { [ string match -nocase $env(ENABLE_TRACE) "true" ] == 1 } {
        exp_internal 1
    }
}

log_file -a $env(LOG_ROOT)/.log/scp.log

# set up some class info
global env
global _CNAME
global _METHOD_NAME
global _LINE_TERMINATOR

set _CNAME "scp"
set _METHOD_NAME "scp"
set _LINE_TERMINATOR "\r\n"
set timeout 10

if { [info exists env(THREAD_TIMEOUT)] } {
    set timeout $env(THREAD_TIMEOUT)
}

proc usage {} {
    global _METHOD_NAME

    puts stderr "$_METHOD_NAME Perform an automated SCP-based task without user interaction.";
    puts stderr "Usage: $_METHOD_NAME \[ type \] \[ src \] \[ dst \] \[ host \] ( authentication mechanism ) ( timeout )";
    puts stderr "\ttype                The transfer type to execute. One of 'local' or 'remote' is required."
    puts stderr "\tsrc                 The source path/file to operate against."
    puts stderr "\tdst                 The target path/file to operate into."
    puts stderr "\thost                The target hostname to connect to. The host must be either an IP address or resolvable hostname."
    puts stderr "\tusername            The user to connect to the remote system as."
    puts stderr "\tauthentication      (Optional) Specify an authentication mechanism. One of 'pass', 'key', or 'file' can be provided in the following formats:"
    puts stderr "\t\t For password authentication: pass:the-password"
    puts stderr "\t\t For key-based authentication: key:/path/to/key. If a passphrase is required by the key, the syntax becomes key:/path/to/key:passphrase"
    puts stderr "\t\t To use a file containing the authentication information. The following syntaxes are available:"
    puts stderr "\t\t\t hostname:username:type:value(:value)"
    puts stderr "\t\t The same syntax rules as above apply here as well."
    puts stderr "\ttimeout             A timeout value for the script to wait if it hangs. If not specified, a value of 10 seconds is used."

    exit 1;
}

## make sure we have all our arguments
if { [ expr { $argc < 3 } ] } {
    usage;
} else {
    ## set runtime information
    set _TARGET_SYSTEM [ lindex $argv 0 ];
    set _EXEC_CMD [ lindex $argv 1 ];
    set _USER_LOGINID [ lindex $argv 2 ];
    set _AUTH_TYPE [ lindex [ split [ lindex $argv 3 ] ":" ] 0 ];

    switch [ lindex $_AUTH_TYPE 0 ] {
        "pass" - "file" - "key" {
            source [ file join [ file dirname [ info script ] ] getAuthValue.tcl ];

            set _AUTH_DATA [ split [ getAuthValue $_TARGET_SYSTEM $_USER_LOGINID [ lindex $argv 3 ] ] ":" ];

            switch [ llength $_AUTH_DATA ] {
                1 {
                    set _USER_PASSWD $_AUTH_DATA;
                }
                2 {
                    set _USER_KEY [ lindex $_AUTH_DATA 0 ];
                    set _USER_PASSWD [ lindex $_AUTH_DATA 1 ];
                }
            }
        }
        default {
            puts stderr "No valid authentication type was provided. Cannot continue.";

            usage;
        }
    }

    if { [ expr { $argc eq 5 } ] } {
        set timeout [ lindex $argv 4 ];
    }
}

switch [ info exists _USER_LOGINID ] {
    0 {
        switch [ string match -nocase $_TRANSFER_TYPE "local" ] {
            0 {
                eval spawn scp -pqrC $_TARGET_SYSTEM:$_DST_FILE $_SRC_FILE
            }
            1 {
                eval spawn scp -pqrC $_SRC_FILE $_TARGET_SYSTEM:$_DST_FILE
            }
            default {
                puts stderr "An invalid transfer type was provided.. Cannot continue."

                exit 1
            }
        }
    }
    1 {
        switch [ info exists _USER_KEY ] {
            0 {
                switch [ string match -nocase $_TRANSFER_TYPE "local" ] {
                    0 {
                        eval spawn scp -pqrC $_USER_LOGINID@$_TARGET_SYSTEM:$_DST_FILE $_SRC_FILE
                    }
                    1 {
                        eval spawn scp -pqrC $_SRC_FILE $_USER_LOGINID@$_TARGET_SYSTEM:$_DST_FILE
                    }
                    default {
                        puts stderr "An invalid transfer type was provided.. Cannot continue."

                        exit 1
                    }
                }
            }
            1 {
                if { [ string match -nocase $_USER_KEY "default" ] } {
                    switch [ string match -nocase $_TRANSFER_TYPE "local" ] {
                        0 {
                            eval spawn scp -pqrC $_USER_LOGINID@$_TARGET_SYSTEM:$_DST_FILE $_SRC_FILE
                        }
                        1 {
                            eval spawn scp -pqrC $_SRC_FILE $_USER_LOGINID@$_TARGET_SYSTEM:$_DST_FILE
                        }
                        default {
                            puts stderr "An invalid transfer type was provided.. Cannot continue."

                            exit 1
                        }
                    }
                } else {
                    switch [ string match -nocase $_TRANSFER_TYPE "local" ] {
                        0 {
                            eval spawn scp -pqrC -i $_USER_KEY $_USER_LOGINID@$_TARGET_SYSTEM:$_DST_FILE $_SRC_FILE
                        }
                        1 {
                            eval spawn scp -pqrC -i $_USER_KEY $_SRC_FILE $_USER_LOGINID@$_TARGET_SYSTEM:$_DST_FILE
                        }
                        default {
                            puts stderr "An invalid transfer type was provided.. Cannot continue."

                            exit 1
                        }
                    }
                }
            }
        }
    }
}

expect {
    "*(yes/no)? " {
        exp_send "yes\r"
        exp_continue
    }
    "*passphrase*" {
        if { [ info exists _USER_KEY ] } {
            exp_send "$_USER_PASSWD\r"
            exp_continue
        }

        exp_send "\r"
        exp_continue
    }
    "*WARNING: Your password has expired.*" {
        puts stderr "Password has expired for user $_USER_LOGINID on host $_TARGET_SYSTEM";

        exit 1;
    }
    "*?assword:*" {
        if { [ expr { $i == 1 } ] } {
            puts stderr "An invalid password was provided for user account $_USER_LOGINID on host $_TARGET_SYSTEM"

            exit 1
        }

        set i [ expr { $i + 1 } ]

        exp_send "$_USER_PASSWD\r"
        exp_continue
    }
    $_LINE_TERMINATOR {
        append output $expect_out(buffer); exp_continue
    }
    eof {
        append output $expect_out(buffer)
    }
}

if { [ info exists output ] } {
    regsub -all -line {^[ \r\t]+|[ \r\t]+$} $output "" _RETURN_DATA
    set _PRINT_DATA [ string trimright $_RETURN_DATA ]

    if { [ string compare -nocase $_PRINT_DATA "" ] != 0 } {
        if { [ string is integer $_PRINT_DATA ] } {
            exit $_PRINT_DATA
        } else {
            puts $_PRINT_DATA

            exit 0
        }
    } else {
        exit 0
    }
}
