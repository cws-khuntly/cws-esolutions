#!/usr/bin/env expect
#==============================================================================
#
#          FILE:  ssh
#         USAGE:  ./ssh
#   DESCRIPTION:  Executes an scp connection to a pre-defined server
#
#       OPTIONS:  ---
#  REQUIREMENTS:  ---
#          BUGS:  ---
#         NOTES:  ---
#        AUTHOR:  Kevin Huntly <kmhuntly@gmail.com>
#       COMPANY:  CaspersBox Web Services
#       VERSION:  1.0
#       CREATED:  ---
#      REVISION:  ---
#==============================================================================

if { [ info exists env(ENABLE_LOG_USER) ] } {
    if { [ string match -nocase $env(ENABLE_LOG_USER) "true" ] == 1 } {
        log_user 1;
    } else {
        log_user 0;
    }
} else {
    log_user 0;
}

if { [ info exists env(DEBUG_TCL) ] } {
    if { [ string match -nocase $env(DEBUG_TCL) "true" ] == 1 } {
        exp_internal 1;
    }
}

log_file -a $env(LOG_ROOT)/.log/ssh.log;

## set up some class info
global env;
global _CNAME;
global _METHOD_NAME;
global _LINE_TERMINATOR;

set _CNAME "ssh";
set _METHOD_NAME "ssh";
set _LINE_TERMINATOR "\r\n";
set _RANDOM_GENERATOR "/dev/urandom";
set _PASSWD_LENGTH "64";
set timeout 10;

if { [info exists env(THREAD_TIMEOUT)] } {
    set timeout $env(THREAD_TIMEOUT);
}

proc usage {} {
    global _METHOD_NAME;

    puts stderr "$_METHOD_NAME Perform an automated SSH-based task without user interaction.";
    puts stderr "Usage: $_METHOD_NAME \[ host \] \[ command \] \[ user \] ( authentication mechanism ) ( timeout )";
    puts stderr "\thost                The target hostname to connect to. The host must be either an IP address or resolvable hostname.";
    puts stderr "\tcommand             The command to execute on the remote system. If an interactive shell is required, specify 'shell' here.";
    puts stderr "\tusername            The user to connect to the remote system as.";
    puts stderr "\tauthentication      (Optional) Specify an authentication mechanism. One of 'pass', 'key', or 'file' can be provided in the following formats:";
    puts stderr "\t\t For password authentication: pass:the-password";
    puts stderr "\t\t For key-based authentication: key:/path/to/key. If a passphrase is required by the key, the syntax becomes key:/path/to/key:passphrase";
    puts stderr "\t\t To use a file containing the authentication information. The following syntaxes are available:";
    puts stderr "\t\t\t hostname:username:type:value(:value)";
    puts stderr "\t\t The same syntax rules as above apply here as well.";
    puts stderr "\ttimeout             A timeout value for the script to wait if it hangs. If not specified, a value of 10 seconds is used.";

    exit 1;
}

## make sure we have all our arguments
if { [ expr { $argc < 3 } ] } {
    usage;
} else {
    ## set runtime information
    set _TARGET_SYSTEM [ lindex $argv 0 ];
    set _EXEC_CMD [ lindex $argv 1 ];
    set _USER_LOGINID [ lindex $argv 2 ];
    set _AUTH_TYPE [ lindex [ split [ lindex $argv 3 ] ":" ] 0 ];

    switch [ lindex $_AUTH_TYPE 0 ] {
        "pass" - "file" - "key" {
            source [ file join [ file dirname [ info script ] ] getAuthValue.tcl ];

            set _AUTH_DATA [ split [ getAuthValue $_TARGET_SYSTEM $_USER_LOGINID [ lindex $argv 3 ] ] ":" ];

            switch [ llength $_AUTH_DATA ] {
                1 {
                    set _USER_PASSWD $_AUTH_DATA;
                }
                2 {
                    set _USER_KEY [ lindex $_AUTH_DATA 0 ];
                    set _USER_PASSWD [ lindex $_AUTH_DATA 1 ];
                }
            }
        }
        default {
            puts stderr "No valid authentication type was provided. Cannot continue.";

            usage;
        }
    }

    if { [ expr { $argc eq 5 } ] } {
        set timeout [ lindex $argv 4 ];
    }
}

switch [ info exists _USER_LOGINID ] {
    0 {
        if { [ string match -nocase $_EXEC_CMD "shell" ] } {
            eval spawn ssh -qaCkt $_TARGET_SYSTEM;
        } else {
            eval spawn ssh -qaCkt $_TARGET_SYSTEM \"$_EXEC_CMD\";
        }
    }
    1 {
        switch [ info exists _USER_KEY ] {
            0 {
                if { [ string match -nocase $_EXEC_CMD "shell" ] } {
                    eval spawn ssh -qaCkt -l $_USER_LOGINID $_TARGET_SYSTEM;
                } else {
                    eval spawn ssh -qaCkt -l $_USER_LOGINID $_TARGET_SYSTEM \"$_EXEC_CMD\";
                }
            }
            1 {
                if { [ string match -nocase $_USER_KEY "default" ] } {
                    if { [ string match -nocase $_EXEC_CMD "shell" ] } {
                        eval spawn ssh -qaCkt -l $_USER_LOGINID $_TARGET_SYSTEM;
                    } else {
                        eval spawn ssh -qaCkt -l $_USER_LOGINID $_TARGET_SYSTEM \"$_EXEC_CMD\";
                    }
                } else {
                    if { [ string match -nocase $_EXEC_CMD "shell" ] } {
                        eval spawn ssh -qaCkt -l $_USER_LOGINID -i $_USER_KEY $_TARGET_SYSTEM;
                    } else {
                        eval spawn ssh -qaCkt -l $_USER_LOGINID -i $_USER_KEY $_TARGET_SYSTEM \"$_EXEC_CMD\";
                    }
                }
            }
        }
    }
}

set i 0;

expect {
    "*(yes/no)? " {
        exp_send "yes\r";
        exp_continue;
    }
    "*$_USER_KEY*" {
        if { [ expr { $i == 1 } ] } {
            puts stderr "An invalid password was provided for user account $_USER_LOGINID on host $_TARGET_SYSTEM";

            exit 1;
        }

        set i [ expr { $i + 1 } ];

        if { [ info exists _USER_PASSWD ] } {
            exp_send "$_USER_PASSWD";
        }

        exp_send "\r";
        exp_continue;
    }
    "*WARNING: Your password has expired.*" {
        ## set up password change here
        set _NEW_PASSWD [ exec /bin/sh -c "cat $_RANDOM_GENERATOR | tr -dc \"A-Za-z0-9_\" | head -c $_PASSWD_LENGTH" ];

        exp_send "$_USER_PASSWD\r";
        expect {
            "*(current) UNIX password:*" {
                exp_continue;
            }
            "*?ld password*" {
                exp_send "$_USER_PASSWD\r";
                exp_continue;
            }
            "*?ew*password*" {
                exp_send "$_NEW_PASSWD\r";
                exp_continue;
            }
            "*Authentication token manipulation error*" {
                puts stderr "Unable to change password for provided user account $_USER_LOGINID on host $_TARGET_SYSTEM";

                exit 1;
            }
            "*BAD PASSWORD: is too simple*" {
                if { ! [ expr { $x > 3 } ] } {
                    set _NEW_PASSWD [ exec /bin/sh -c "cat $_RANDOM_GENERATOR | tr -dc \"A-Za-z0-9_\" | head -c $_PASSWD_LENGTH" ];
                    set x [ expr { $x + 1 } ];
                } else {
                    puts stderr "Unable to change password for provided user account $_USER_LOGINID on host $_TARGET_SYSTEM";

                    exit 1;
                }

                set x [ expr { $x + 1 } ];
                set _NEW_PASSWD [ exec /bin/sh -c "cat $_RANDOM_GENERATOR | tr -dc \"A-Za-z0-9_\" | head -c $_PASSWD_LENGTH" ];

                exp_continue;
            }
            "*passwd: Have exhausted maximum number of retries for service*" {
                puts stderr "Unable to change password for provided user account $_USER_LOGINID on host $_TARGET_SYSTEM";

                exit 1;
            }
            "*passwd: all authentication tokens updated successfully.*" {
                ## success!
                puts stdout "Password for $_TARGET_SYSTEM set to $_NEW_PASSWD";

                exit 0;
            }
        }
    }
    "*?assword*" {
        if { [ expr { $i == 1 } ] } {
            puts stderr "An invalid password was provided for user account $_USER_LOGINID on host $_TARGET_SYSTEM";

            exit 1;
        }

        set i [ expr { $i + 1 } ];

        exp_send "$_USER_PASSWD\r";
        exp_continue;
    }
    $_LINE_TERMINATOR {
        expect {
            "*?assword*" {
                if { [ expr { $i == 1 } ] } {
                    puts stderr "An invalid password was provided for user account $_USER_LOGINID on host $_TARGET_SYSTEM";

                    exit 1;
                }

                set i [ expr { $i + 1 } ];

                exp_send "$_USER_PASSWD\r";
                exp_continue;
            }
            $_LINE_TERMINATOR {
                if { [ string compare $_EXEC_CMD "shell" ] == 0 } {
                    interact;
                } else {
                    append output $expect_out(buffer);
                    exp_continue;
                }
            }
            eof {
                append output $expect_out(buffer);
            }
        }
    }
    eof {
        append output $expect_out(buffer);
    }
}

if { [ info exists output ] eq 1 } {
    regsub -all -line {^[ \r\t]+|[ \r\t]+$} $output "" _RETURN_DATA;
    set _PRINT_DATA [ string trimright $_RETURN_DATA ];

    if { [ string compare -nocase $_PRINT_DATA "" ] != 0 } {
        if { [ string is integer $_PRINT_DATA ] } {
            exit $_PRINT_DATA;
        } else {
            puts $_PRINT_DATA;

            exit 0;
        }
    } else {
        exit 0;
    }
}
