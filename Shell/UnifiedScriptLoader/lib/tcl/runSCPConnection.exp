#!/usr/bin/env expect
#==============================================================================
#
#          FILE:  runSCPConnection.exp
#         USAGE:  ./runSCPConnection.exp
#   DESCRIPTION:  Executes an scp connection to a pre-defined server
#
#       OPTIONS:  ---
#  REQUIREMENTS:  ---
#          BUGS:  ---
#         NOTES:  ---
#        AUTHOR:  Kevin Huntly <kmhuntly@gmail.com>
#       COMPANY:  CaspersBox Web Services
#       VERSION:  1.0
#       CREATED:  ---
#      REVISION:  ---
#
#==============================================================================

global env
global _CNAME
global _METHOD_NAME
global _LINE_TERMINATOR

log_user 0
log_file -a $env(LOG_ROOT)/runSCPConnection.log

## set up some class info
set _CNAME "runSCPConnection"
set _METHOD_NAME "runSCPConnection"
set _LINE_TERMINATOR "\r\n"
set timeout 10

if { [ info exists env(ENABLE_TRACE) ] } {
    if { [ string match -nocase $env(ENABLE_TRACE) "true" ] == 1 } {
        log_user 1
    }
}

if { [info exists env(THREAD_TIMEOUT)] } {
    set timeout $env(THREAD_TIMEOUT)
}

proc usage {} {
    global _CNAME

    puts "$_CNAME Perform an automated SCP-based task without user interaction.";
    puts "Usage: $_CNAME \[ type \] \[ src \] \[ dst \] \[ host \] ( authentication mechanism ) ( timeout )";
    puts "\ttype                The transfer type to execute. One of 'local' or 'remote' is required."
    puts "\tsrc                 The source path/file to operate against."
    puts "\tdst                 The target path/file to operate into."
    puts "\thost                The target hostname to connect to. The host must be either an IP address or resolvable hostname."
    puts "\tusername            The user to connect to the remote system as."
    puts "\tauthentication      (Optional) Specify an authentication mechanism. One of 'pass', 'key', or 'file' can be provided in the following formats:"
    puts "\t\t For password authentication: pass:the-password"
    puts "\t\t For key-based authentication: key:/path/to/key. If a passphrase is required by the key, the syntax becomes key:/path/to/key:passphrase"
    puts "\t\t To use a file containing the authentication information. The following syntaxes are available:"
    puts "\t\t\t hostname:username:type:value(:value)"
    puts "\t\t The same syntax rules as above apply here as well."
}

# make sure we have all our arguments
if { [ expr $argc < 4 ] } {
    usage

    exit 1
} else {
    # set runtime information
    set _TRANSFER_TYPE [ lindex $argv 0 ]
    set _SRC_FILE [ lindex $argv 1 ]
    set _DST_FILE [ lindex $argv 2 ]
    set _TARGET_SYSTEM [ lindex $argv 3 ]
    set _USER_LOGINID [ lindex $argv 4 ]

    if { [ string compare -nocase $_USER_LOGINID "root" ] == 0 } {
        puts "This utility cannot be used to perform superuser functionality.";

        exit 99
    }

    # type it
    if { [string compare -nocase [ lindex $argv 5 ] ""] != 0 } {
        set _AUTH_STRING [ split [ lindex $argv 5 ] ":" ]

        if { [ string compare -nocase [ lindex $_AUTH_STRING 0 ] "pass" ] == 0 } {
            # password authentication only
            set _USER_PASSWD [ lindex $_AUTH_STRING 1 ]
        } elseif { [ string compare -nocase [ lindex $_AUTH_STRING 0 ] "key" ] == 0 } {
            # key auth
            set _USER_KEY [ lindex $_AUTH_STRING 1 ]

            if { [ llength $_AUTH_STRING ] == 3 } {
                # key has a password
                set _USER_PASSWD [ lindex $_AUTH_STRING 2 ]
            }
        } elseif { [ string compare -nocase [ lindex $_AUTH_STRING 0 ] "file" ] == 0 } {
            set file [ open [ lindex $_AUTH_STRING 1 ] r ]
            fconfigure $file -buffering line

            while { [ gets $file line ] >= 0 } {
                if { [ string match "$$*" $line ] || [ string match "$ #*" $line ] } {
                    # ignore by just going straight to the next loop iteration
                    continue
                }

                set _AUTH_ENTRY [ split $line ":" ]

                if { [ string equal -nocase -length [ string length $_TARGET_SYSTEM ] $_TARGET_SYSTEM [ lindex $_AUTH_ENTRY 0 ] ] == 1 } {
                    if { [ string equal -nocase -length [ string length $_USER_LOGINID ] $_USER_LOGINID [ lindex $_AUTH_ENTRY 1 ] ] == 1 } {
                        set _AUTH_DATA $_AUTH_ENTRY

                        break
                    } else {
                        continue
                    }
                } else {
                    continue
                }

                if { [ string equal -nocase -length [ string length $_USER_LOGINID ] $_USER_LOGINID [ lindex $_AUTH_ENTRY 0 ] ] == 1 } {
                    set _AUTH_DATA $_AUTH_ENTRY

                    break
                } else {
                    continue
                }
            }

            close $file

            # check what we have
            # two possible formats:
            # host:user:type:value(:value) (0:1:2:3:4)
            # user:type:value(:value)  (0:1:2:3)
            if { [ string equal -nocase -length [ string length $_TARGET_SYSTEM ] $_TARGET_SYSTEM [ lindex $_AUTH_DATA 0 ] ] == 1 } {
                if { [ string compare -nocase [ lindex $_AUTH_DATA 2 ] "pass" ] == 0 } {
                    # password authentication only
                    set _USER_PASSWD [ lindex $_AUTH_DATA 3 ]
                } elseif { [ string compare -nocase [ lindex $_AUTH_DATA 2 ] "key" ] == 0 } {
                    # key auth
                    set _USER_KEY [ lindex $_AUTH_DATA 3 ]

                    if { [ llength $_AUTH_DATA ] == 5 } {
                        # key has a password
                        set _USER_PASSWD [ lindex $_AUTH_DATA 4 ]
                    }
                } else {
                    puts "No valid authentication type was provided. Cannot continue."

                    exit 1
                }
            } elseif { [ string equal -nocase -length [ string length $_USER_LOGINID ] $_USER_LOGINID [ lindex $_AUTH_DATA 0 ] ] == 1 } {
                if { [ string compare -nocase [ lindex $_AUTH_DATA 1 ] "pass" ] == 0 } {
                    # password authentication only
                    set _USER_PASSWD [ lindex $_AUTH_DATA 2 ]
                } elseif { [ string compare -nocase [ lindex $_AUTH_DATA 1 ] "key" ] == 0 } {
                    # key auth
                    set _USER_KEY [ lindex $_AUTH_DATA 2 ]

                    if { [ llength $_AUTH_DATA ] == 4 } {
                        # key has a password
                        set _USER_PASSWD [ lindex $_AUTH_DATA 3 ]
                    }
                } else {
                    puts "No valid authentication type was provided. Cannot continue."

                    exit 1
                }
            } else {
                puts "No valid authentication data was provided. Cannot continue."

                exit 1
            }
        } else {
            puts "No valid authentication type was provided. Cannot continue."

            exit 1
        }
    }
}

# sleep for about ten seconds
# for some reason if this script
# is executed immediately after
# a previous execution, it breaks
sleep $env(EXECUTION_DELAY)

# spawn the ssh connection
if { [ info exists _USER_LOGINID ] } {
    if { [ info exists _USER_KEY ] } {
        if { [ string compare -nocase $_USER_KEY "default" ] == 0 } {
            if { [ string compare -nocase $_TRANSFER_TYPE "local" ] == 0 } {
                set _SCP_COMMAND "scp $_SRC_FILE $_USER_LOGINID@$_TARGET_SYSTEM:$_DST_FILE"
            } elseif { [ string compare -nocase $_TRANSFER_TYPE "remote" ] == 0 } {
                set _SCP_COMMAND "scp $_USER_LOGINID@$_TARGET_SYSTEM:$_SRC_FILE $_DST_FILE "
            } else {
                puts "No valid command type was provided. Cannot continue."
                exit 27
            }
        } else {
            if { [ string compare -nocase $_TRANSFER_TYPE "local" ] == 0 } {
                set _SCP_COMMAND "scp -i $_USER_KEY $_SRC_FILE $_USER_LOGINID@$_TARGET_SYSTEM:$_DST_FILE"
            } elseif { [ string compare -nocase $_TRANSFER_TYPE "remote" ] == 0 } {
                set _SCP_COMMAND "scp -i $_USER_KEY $_USER_LOGINID@$_TARGET_SYSTEM:$_SRC_FILE $_DST_FILE "
            } else {
                puts "No valid command type was provided. Cannot continue."
                exit 27
            }
        }
    } else {
        if { [ string compare -nocase $_TRANSFER_TYPE "local" ] == 0 } {
            set _SCP_COMMAND "scp $_SRC_FILE $_USER_LOGINID@$_TARGET_SYSTEM:$_DST_FILE"
        } elseif { [ string compare -nocase $_TRANSFER_TYPE "remote" ] == 0 } {
            set _SCP_COMMAND "scp $_USER_LOGINID@$_TARGET_SYSTEM:$_SRC_FILE $_DST_FILE "
        } else {
            puts "No valid command type was provided. Cannot continue."
            exit 27
        }
    }
} else {
    if { [ info exists _USER_KEY ] } {
        if { [ string compare -nocase $_USER_KEY "default" ] == 0 } {
            if { [ string compare -nocase $_TRANSFER_TYPE "local" ] == 0 } {
                set _SCP_COMMAND "scp $_SRC_FILE $_TARGET_SYSTEM:$_DST_FILE"
            } elseif { [ string compare -nocase $_TRANSFER_TYPE "remote" ] == 0 } {
                set _SCP_COMMAND "scp $_TARGET_SYSTEM:$_SRC_FILE $_DST_FILE "
            } else {
                puts "No valid command type was provided. Cannot continue."
                exit 27
            }
        } else {
            if { [ string compare -nocase $_TRANSFER_TYPE "local" ] == 0 } {
                set _SCP_COMMAND "scp -i $_USER_KEY $_SRC_FILE $_TARGET_SYSTEM:$_DST_FILE"
            } elseif { [ string compare -nocase $_TRANSFER_TYPE "remote" ] == 0 } {
                set _SCP_COMMAND "scp -i $_USER_KEY $_TARGET_SYSTEM:$_SRC_FILE $_DST_FILE "
            } else {
                puts "No valid command type was provided. Cannot continue."
                exit 27
            }
        }
    } else {
        if { [ string compare -nocase $_TRANSFER_TYPE "local" ] == 0 } {
            set _SCP_COMMAND "scp $_SRC_FILE $_TARGET_SYSTEM:$_DST_FILE"
        } elseif { [ string compare -nocase $_TRANSFER_TYPE "remote" ] == 0 } {
            set _SCP_COMMAND "scp $_TARGET_SYSTEM:$_SRC_FILE $_DST_FILE "
        } else {
            puts "No valid command type was provided. Cannot continue."
            exit 27
        }
    }
}

if { [ info exists _SCP_COMMAND ] } {
    eval spawn $_SCP_COMMAND

    set i 0

    expect {
        "*(yes/no)? " {
            exp_send "yes\r"
            exp_continue
        }
        "*?assword:*" {
            if { [ expr { $i == 1 } ] } {
                puts "An invalid password was provided for user account $_USER_LOGINID on host $_TARGET_SYSTEM"

                exit 1
            }

            exp_send "$_USER_PASSWD\r"

            set i [ expr { $i + 1 } ]

            exp_continue
        }
        $_LINE_TERMINATOR {
            if { [ string compare $_EXEC_CMD "shell" ] == 0 } {
                interact
            } else {
                append output $expect_out(buffer); exp_continue
            }
        }
        eof {
            append output $expect_out(buffer)
        }
    }

    if { [ info exists output ] } {
        regsub -all -line {^[ \r\t]+|[ \r\t]+$} $output "" _RETURN_DATA
        set _PRINT_DATA [ string trimright $_RETURN_DATA ]

        if { [ string compare -nocase $_PRINT_DATA "" ] != 0 } {
            if { [ string is integer $_PRINT_DATA ] } {
                exit $_PRINT_DATA
            } else {
                puts $_PRINT_DATA

                exit 0
            }
        } else {
            exit 0
        }
    }
} else {
    puts "No valid SSH command was generated. Cannot continue."
    exit 27
}
